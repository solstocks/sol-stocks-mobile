{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.solanaPayService=exports.SolanaPayService=void 0;var _asyncToGenerator2=_interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));var _classCallCheck2=_interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2=_interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _pay=require(\"@solana/pay\");var _web=require(\"@solana/web3.js\");var _solanaConfig=require(\"./solanaConfig\");var _asyncStorage=_interopRequireDefault(require(\"@react-native-async-storage/async-storage\"));var SolanaPayService=exports.SolanaPayService=function(){function SolanaPayService(){(0,_classCallCheck2.default)(this,SolanaPayService);this.connection=_solanaConfig.connection;}return(0,_createClass2.default)(SolanaPayService,[{key:\"createStockPurchaseURL\",value:(function(){var _createStockPurchaseURL=(0,_asyncToGenerator2.default)(function*(payment,paymentMethod='SOL'){try{var reference=new _web.PublicKey(Array(32).fill(0).map(function(){return Math.floor(Math.random()*256);}));var transferRequest={recipient:_solanaConfig.PROJECT_TREASURY,amount:paymentMethod==='SOL'?payment.solAmount+payment.feeSOL:payment.bonkAmount||0,splToken:paymentMethod==='BONK'?_solanaConfig.BONK_MINT:undefined,reference,label:`Sol Stocks - ${payment.stockSymbol}`,message:`Purchase ${payment.quantity} shares of ${payment.stockSymbol} for $${payment.totalUSD.toFixed(2)}`,memo:`STOCK_PURCHASE:${payment.stockSymbol}:${payment.quantity}:${paymentMethod}`};var url=(0,_pay.encodeURL)(transferRequest);yield this.storePaymentReference(reference.toBase58(),{...payment,paymentMethod,timestamp:Date.now(),status:'pending'});return{url,reference};}catch(error){console.error('Failed to create payment URL:',error);throw new Error('Failed to create payment URL');}});function createStockPurchaseURL(_x){return _createStockPurchaseURL.apply(this,arguments);}return createStockPurchaseURL;}())},{key:\"createStockPurchaseTransaction\",value:(function(){var _createStockPurchaseTransaction=(0,_asyncToGenerator2.default)(function*(userPublicKey,payment,paymentMethod='SOL'){try{var transaction=new _web.Transaction();if(paymentMethod==='SOL'){var stockTransfer=_web.SystemProgram.transfer({fromPubkey:userPublicKey,toPubkey:_solanaConfig.PROJECT_TREASURY,lamports:payment.solAmount*_web.LAMPORTS_PER_SOL});transaction.add(stockTransfer);var feeTransfer=_web.SystemProgram.transfer({fromPubkey:userPublicKey,toPubkey:_solanaConfig.PROJECT_TREASURY,lamports:payment.feeSOL*_web.LAMPORTS_PER_SOL});transaction.add(feeTransfer);}else if(paymentMethod==='BONK'&&payment.bonkAmount){var totalSOL=payment.solAmount+payment.feeSOL;var transfer=_web.SystemProgram.transfer({fromPubkey:userPublicKey,toPubkey:_solanaConfig.PROJECT_TREASURY,lamports:totalSOL*_web.LAMPORTS_PER_SOL});transaction.add(transfer);}var memoInstruction=new _web.Transaction().add(_web.SystemProgram.transfer({fromPubkey:userPublicKey,toPubkey:userPublicKey,lamports:0}));var _yield$this$connectio=yield this.connection.getLatestBlockhash(),blockhash=_yield$this$connectio.blockhash;transaction.recentBlockhash=blockhash;transaction.feePayer=userPublicKey;return transaction;}catch(error){console.error('Failed to create transaction:',error);throw new Error('Failed to create stock purchase transaction');}});function createStockPurchaseTransaction(_x2,_x3){return _createStockPurchaseTransaction.apply(this,arguments);}return createStockPurchaseTransaction;}())},{key:\"calculateTradingFee\",value:function calculateTradingFee(stockSymbol,amount,action='buy'){var category='traditional';var cryptoStocks=['COIN','MSTR','RIOT','MARA','HOOD','SQ','VANA','BTBT','BTCS','SBET','GAME','UPXI'];var premiumStocks=['CIRCLE','GEMINI','KRAKEN','OPENSEA'];if(cryptoStocks.includes(stockSymbol)){category='crypto';}else if(premiumStocks.includes(stockSymbol)){category='premium';}var feeConfig=_solanaConfig.FEE_STRUCTURE[category];var feePercent=action==='buy'?feeConfig.buyFeePercent:feeConfig.sellFeePercent;var feeSOL=amount*feePercent/100;feeSOL=Math.max(feeConfig.minFeeSOL,Math.min(feeSOL,feeConfig.maxFeeSOL));return{category,feeSOL,feePercent};}},{key:\"convertUSDToTokens\",value:function convertUSDToTokens(usdAmount){var solAmount=usdAmount/_solanaConfig.MOCK_SOL_PRICE_USD;var bonkAmount=usdAmount*1000000;return{solAmount,bonkAmount};}},{key:\"createStockPurchasePayment\",value:function createStockPurchasePayment(stockSymbol,stockPrice,quantity){var totalUSD=stockPrice*quantity;var _this$convertUSDToTok=this.convertUSDToTokens(totalUSD),solAmount=_this$convertUSDToTok.solAmount,bonkAmount=_this$convertUSDToTok.bonkAmount;var _this$calculateTradin=this.calculateTradingFee(stockSymbol,solAmount,'buy'),category=_this$calculateTradin.category,feeSOL=_this$calculateTradin.feeSOL;return{stockSymbol,stockPrice,quantity,totalUSD,solAmount,bonkAmount,feeSOL,category};}},{key:\"confirmPayment\",value:(function(){var _confirmPayment=(0,_asyncToGenerator2.default)(function*(reference,timeout=60000){try{var startTime=Date.now();while(Date.now()-startTime<timeout){try{var signature=yield(0,_pay.findTransactionSignature)(this.connection,reference,undefined,'confirmed');if(signature){var isValid=yield(0,_pay.validateTransactionSignature)(this.connection,signature,_solanaConfig.PROJECT_TREASURY,undefined,reference,'confirmed');if(isValid){var paymentDetails=yield this.getPaymentReference(reference.toBase58());if(paymentDetails){yield this.updatePaymentStatus(reference.toBase58(),'confirmed',signature);}return{signature,confirmed:true,paymentDetails};}}}catch(error){}yield new Promise(function(resolve){return setTimeout(resolve,2000);});}return{signature:'',confirmed:false};}catch(error){console.error('Payment confirmation failed:',error);return{signature:'',confirmed:false};}});function confirmPayment(_x4){return _confirmPayment.apply(this,arguments);}return confirmPayment;}())},{key:\"storePaymentReference\",value:(function(){var _storePaymentReference=(0,_asyncToGenerator2.default)(function*(reference,paymentData){try{yield _asyncStorage.default.setItem(`payment_${reference}`,JSON.stringify(paymentData));}catch(error){console.error('Failed to store payment reference:',error);}});function storePaymentReference(_x5,_x6){return _storePaymentReference.apply(this,arguments);}return storePaymentReference;}())},{key:\"getPaymentReference\",value:(function(){var _getPaymentReference=(0,_asyncToGenerator2.default)(function*(reference){try{var data=yield _asyncStorage.default.getItem(`payment_${reference}`);return data?JSON.parse(data):null;}catch(error){console.error('Failed to get payment reference:',error);return null;}});function getPaymentReference(_x7){return _getPaymentReference.apply(this,arguments);}return getPaymentReference;}())},{key:\"updatePaymentStatus\",value:(function(){var _updatePaymentStatus=(0,_asyncToGenerator2.default)(function*(reference,status,signature){try{var existingData=yield this.getPaymentReference(reference);if(existingData){var updatedData={...existingData,status,signature,confirmedAt:status==='confirmed'?Date.now():undefined};yield _asyncStorage.default.setItem(`payment_${reference}`,JSON.stringify(updatedData));}}catch(error){console.error('Failed to update payment status:',error);}});function updatePaymentStatus(_x8,_x9,_x0){return _updatePaymentStatus.apply(this,arguments);}return updatePaymentStatus;}())},{key:\"getPaymentHistory\",value:(function(){var _getPaymentHistory=(0,_asyncToGenerator2.default)(function*(){try{var keys=yield _asyncStorage.default.getAllKeys();var paymentKeys=keys.filter(function(key){return key.startsWith('payment_');});var payments=yield Promise.all(paymentKeys.map(function(){var _ref=(0,_asyncToGenerator2.default)(function*(key){try{var data=yield _asyncStorage.default.getItem(key);return data?JSON.parse(data):null;}catch{return null;}});return function(_x1){return _ref.apply(this,arguments);};}()));return payments.filter(function(payment){return payment!==null;}).sort(function(a,b){return b.timestamp-a.timestamp;});}catch(error){console.error('Failed to get payment history:',error);return[];}});function getPaymentHistory(){return _getPaymentHistory.apply(this,arguments);}return getPaymentHistory;}())}]);}();var solanaPayService=exports.solanaPayService=new SolanaPayService();","map":{"version":3,"names":["_pay","require","_web","_solanaConfig","_asyncStorage","_interopRequireDefault","SolanaPayService","exports","_classCallCheck2","default","connection","_createClass2","key","value","_createStockPurchaseURL","_asyncToGenerator2","payment","paymentMethod","reference","PublicKey","Array","fill","map","Math","floor","random","transferRequest","recipient","PROJECT_TREASURY","amount","solAmount","feeSOL","bonkAmount","splToken","BONK_MINT","undefined","label","stockSymbol","message","quantity","totalUSD","toFixed","memo","url","encodeURL","storePaymentReference","toBase58","timestamp","Date","now","status","error","console","Error","createStockPurchaseURL","_x","apply","arguments","_createStockPurchaseTransaction","userPublicKey","transaction","Transaction","stockTransfer","SystemProgram","transfer","fromPubkey","toPubkey","lamports","LAMPORTS_PER_SOL","add","feeTransfer","totalSOL","memoInstruction","_yield$this$connectio","getLatestBlockhash","blockhash","recentBlockhash","feePayer","createStockPurchaseTransaction","_x2","_x3","calculateTradingFee","action","category","cryptoStocks","premiumStocks","includes","feeConfig","FEE_STRUCTURE","feePercent","buyFeePercent","sellFeePercent","max","minFeeSOL","min","maxFeeSOL","convertUSDToTokens","usdAmount","MOCK_SOL_PRICE_USD","createStockPurchasePayment","stockPrice","_this$convertUSDToTok","_this$calculateTradin","_confirmPayment","timeout","startTime","signature","findTransactionSignature","isValid","validateTransactionSignature","paymentDetails","getPaymentReference","updatePaymentStatus","confirmed","Promise","resolve","setTimeout","confirmPayment","_x4","_storePaymentReference","paymentData","AsyncStorage","setItem","JSON","stringify","_x5","_x6","_getPaymentReference","data","getItem","parse","_x7","_updatePaymentStatus","existingData","updatedData","confirmedAt","_x8","_x9","_x0","_getPaymentHistory","keys","getAllKeys","paymentKeys","filter","startsWith","payments","all","_ref","_x1","sort","a","b","getPaymentHistory","solanaPayService"],"sources":["/Users/sarahfitzgerald/SolStocksMobile/src/utils/solanaPayIntegration.ts"],"sourcesContent":["import {\n  createTransfer,\n  createTransferInstruction,\n  encodeURL,\n  findTransactionSignature,\n  parseURL,\n  validateTransactionSignature,\n  TransferRequestURL,\n  TransactionRequestURL,\n} from '@solana/pay';\nimport {\n  Connection,\n  PublicKey,\n  SystemProgram,\n  Transaction,\n  LAMPORTS_PER_SOL,\n  SendOptions,\n} from '@solana/web3.js';\nimport { connection, PROJECT_TREASURY, FEE_STRUCTURE, MOCK_SOL_PRICE_USD, BONK_MINT } from './solanaConfig';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nexport interface PaymentRequest {\n  recipient: PublicKey;\n  amount: number;\n  splToken?: PublicKey;\n  reference?: PublicKey;\n  label?: string;\n  message?: string;\n  memo?: string;\n}\n\nexport interface StockPurchasePayment {\n  stockSymbol: string;\n  stockPrice: number;\n  quantity: number;\n  totalUSD: number;\n  solAmount: number;\n  bonkAmount?: number;\n  feeSOL: number;\n  category: 'traditional' | 'crypto' | 'premium';\n}\n\n/**\n * Solana Pay integration for mobile payments\n * Supports both SOL and BONK token payments\n */\nexport class SolanaPayService {\n  private connection: Connection;\n\n  constructor() {\n    this.connection = connection;\n  }\n\n  /**\n   * Create a Solana Pay transfer URL for stock purchases\n   */\n  async createStockPurchaseURL(\n    payment: StockPurchasePayment,\n    paymentMethod: 'SOL' | 'BONK' = 'SOL'\n  ): Promise<{ url: URL; reference: PublicKey }> {\n    try {\n      const reference = new PublicKey(Array(32).fill(0).map(() => Math.floor(Math.random() * 256)));\n      \n      const transferRequest: TransferRequestURL = {\n        recipient: PROJECT_TREASURY,\n        amount: paymentMethod === 'SOL' ? payment.solAmount + payment.feeSOL : payment.bonkAmount || 0,\n        splToken: paymentMethod === 'BONK' ? BONK_MINT : undefined,\n        reference,\n        label: `Sol Stocks - ${payment.stockSymbol}`,\n        message: `Purchase ${payment.quantity} shares of ${payment.stockSymbol} for $${payment.totalUSD.toFixed(2)}`,\n        memo: `STOCK_PURCHASE:${payment.stockSymbol}:${payment.quantity}:${paymentMethod}`,\n      };\n\n      const url = encodeURL(transferRequest);\n      \n      // Store payment details for confirmation\n      await this.storePaymentReference(reference.toBase58(), {\n        ...payment,\n        paymentMethod,\n        timestamp: Date.now(),\n        status: 'pending',\n      });\n\n      return { url, reference };\n    } catch (error) {\n      console.error('Failed to create payment URL:', error);\n      throw new Error('Failed to create payment URL');\n    }\n  }\n\n  /**\n   * Create a direct transfer instruction for mobile wallet\n   */\n  async createStockPurchaseTransaction(\n    userPublicKey: PublicKey,\n    payment: StockPurchasePayment,\n    paymentMethod: 'SOL' | 'BONK' = 'SOL'\n  ): Promise<Transaction> {\n    try {\n      const transaction = new Transaction();\n      \n      if (paymentMethod === 'SOL') {\n        // Add stock purchase amount transfer\n        const stockTransfer = SystemProgram.transfer({\n          fromPubkey: userPublicKey,\n          toPubkey: PROJECT_TREASURY,\n          lamports: payment.solAmount * LAMPORTS_PER_SOL,\n        });\n        transaction.add(stockTransfer);\n\n        // Add trading fee transfer\n        const feeTransfer = SystemProgram.transfer({\n          fromPubkey: userPublicKey,\n          toPubkey: PROJECT_TREASURY,\n          lamports: payment.feeSOL * LAMPORTS_PER_SOL,\n        });\n        transaction.add(feeTransfer);\n      } else if (paymentMethod === 'BONK' && payment.bonkAmount) {\n        // BONK token transfer (would need SPL token program instructions)\n        // For now, we'll implement SOL fallback\n        const totalSOL = payment.solAmount + payment.feeSOL;\n        const transfer = SystemProgram.transfer({\n          fromPubkey: userPublicKey,\n          toPubkey: PROJECT_TREASURY,\n          lamports: totalSOL * LAMPORTS_PER_SOL,\n        });\n        transaction.add(transfer);\n      }\n\n      // Add memo instruction for transaction tracking\n      const memoInstruction = new Transaction().add(\n        SystemProgram.transfer({\n          fromPubkey: userPublicKey,\n          toPubkey: userPublicKey,\n          lamports: 0,\n        })\n      );\n      \n      // Set recent blockhash\n      const { blockhash } = await this.connection.getLatestBlockhash();\n      transaction.recentBlockhash = blockhash;\n      transaction.feePayer = userPublicKey;\n\n      return transaction;\n    } catch (error) {\n      console.error('Failed to create transaction:', error);\n      throw new Error('Failed to create stock purchase transaction');\n    }\n  }\n\n  /**\n   * Calculate trading fees based on stock category\n   */\n  calculateTradingFee(\n    stockSymbol: string,\n    amount: number,\n    action: 'buy' | 'sell' = 'buy'\n  ): { category: 'traditional' | 'crypto' | 'premium'; feeSOL: number; feePercent: number } {\n    // Determine stock category\n    let category: 'traditional' | 'crypto' | 'premium' = 'traditional';\n    \n    const cryptoStocks = ['COIN', 'MSTR', 'RIOT', 'MARA', 'HOOD', 'SQ', 'VANA', 'BTBT', 'BTCS', 'SBET', 'GAME', 'UPXI'];\n    const premiumStocks = ['CIRCLE', 'GEMINI', 'KRAKEN', 'OPENSEA'];\n    \n    if (cryptoStocks.includes(stockSymbol)) {\n      category = 'crypto';\n    } else if (premiumStocks.includes(stockSymbol)) {\n      category = 'premium';\n    }\n\n    const feeConfig = FEE_STRUCTURE[category];\n    const feePercent = action === 'buy' ? feeConfig.buyFeePercent : feeConfig.sellFeePercent;\n    \n    let feeSOL = (amount * feePercent) / 100;\n    \n    // Apply min/max limits\n    feeSOL = Math.max(feeConfig.minFeeSOL, Math.min(feeSOL, feeConfig.maxFeeSOL));\n\n    return { category, feeSOL, feePercent };\n  }\n\n  /**\n   * Convert USD amount to SOL and BONK equivalents\n   */\n  convertUSDToTokens(usdAmount: number): { solAmount: number; bonkAmount: number } {\n    const solAmount = usdAmount / MOCK_SOL_PRICE_USD;\n    const bonkAmount = usdAmount * 1000000; // Mock BONK rate: 1 USD = 1M BONK\n    \n    return { solAmount, bonkAmount };\n  }\n\n  /**\n   * Create complete stock purchase payment object\n   */\n  createStockPurchasePayment(\n    stockSymbol: string,\n    stockPrice: number,\n    quantity: number\n  ): StockPurchasePayment {\n    const totalUSD = stockPrice * quantity;\n    const { solAmount, bonkAmount } = this.convertUSDToTokens(totalUSD);\n    const { category, feeSOL } = this.calculateTradingFee(stockSymbol, solAmount, 'buy');\n\n    return {\n      stockSymbol,\n      stockPrice,\n      quantity,\n      totalUSD,\n      solAmount,\n      bonkAmount,\n      feeSOL,\n      category,\n    };\n  }\n\n  /**\n   * Confirm payment by checking transaction on blockchain\n   */\n  async confirmPayment(reference: PublicKey, timeout: number = 60000): Promise<{\n    signature: string;\n    confirmed: boolean;\n    paymentDetails?: any;\n  }> {\n    try {\n      const startTime = Date.now();\n      \n      while (Date.now() - startTime < timeout) {\n        try {\n          // Look for transaction with this reference\n          const signature = await findTransactionSignature(\n            this.connection,\n            reference,\n            undefined,\n            'confirmed'\n          );\n\n          if (signature) {\n            // Validate the transaction\n            const isValid = await validateTransactionSignature(\n              this.connection,\n              signature,\n              PROJECT_TREASURY,\n              undefined,\n              reference,\n              'confirmed'\n            );\n\n            if (isValid) {\n              // Get stored payment details\n              const paymentDetails = await this.getPaymentReference(reference.toBase58());\n              \n              // Update payment status\n              if (paymentDetails) {\n                await this.updatePaymentStatus(reference.toBase58(), 'confirmed', signature);\n              }\n\n              return {\n                signature,\n                confirmed: true,\n                paymentDetails,\n              };\n            }\n          }\n        } catch (error) {\n          // Continue polling\n        }\n\n        // Wait before next check\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      }\n\n      return {\n        signature: '',\n        confirmed: false,\n      };\n    } catch (error) {\n      console.error('Payment confirmation failed:', error);\n      return {\n        signature: '',\n        confirmed: false,\n      };\n    }\n  }\n\n  /**\n   * Store payment reference for tracking\n   */\n  private async storePaymentReference(reference: string, paymentData: any): Promise<void> {\n    try {\n      await AsyncStorage.setItem(`payment_${reference}`, JSON.stringify(paymentData));\n    } catch (error) {\n      console.error('Failed to store payment reference:', error);\n    }\n  }\n\n  /**\n   * Get payment reference data\n   */\n  private async getPaymentReference(reference: string): Promise<any> {\n    try {\n      const data = await AsyncStorage.getItem(`payment_${reference}`);\n      return data ? JSON.parse(data) : null;\n    } catch (error) {\n      console.error('Failed to get payment reference:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Update payment status\n   */\n  private async updatePaymentStatus(\n    reference: string,\n    status: 'pending' | 'confirmed' | 'failed',\n    signature?: string\n  ): Promise<void> {\n    try {\n      const existingData = await this.getPaymentReference(reference);\n      if (existingData) {\n        const updatedData = {\n          ...existingData,\n          status,\n          signature,\n          confirmedAt: status === 'confirmed' ? Date.now() : undefined,\n        };\n        await AsyncStorage.setItem(`payment_${reference}`, JSON.stringify(updatedData));\n      }\n    } catch (error) {\n      console.error('Failed to update payment status:', error);\n    }\n  }\n\n  /**\n   * Get payment history\n   */\n  async getPaymentHistory(): Promise<any[]> {\n    try {\n      const keys = await AsyncStorage.getAllKeys();\n      const paymentKeys = keys.filter(key => key.startsWith('payment_'));\n      \n      const payments = await Promise.all(\n        paymentKeys.map(async (key) => {\n          try {\n            const data = await AsyncStorage.getItem(key);\n            return data ? JSON.parse(data) : null;\n          } catch {\n            return null;\n          }\n        })\n      );\n\n      return payments\n        .filter(payment => payment !== null)\n        .sort((a, b) => b.timestamp - a.timestamp);\n    } catch (error) {\n      console.error('Failed to get payment history:', error);\n      return [];\n    }\n  }\n}\n\n// Export singleton instance\nexport const solanaPayService = new SolanaPayService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}