{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.addNode=addNode;exports.attachListeners=attachListeners;exports.getResponderNode=getResponderNode;exports.removeNode=removeNode;exports.terminateResponder=terminateResponder;var _createResponderEvent=_interopRequireDefault(require(\"./createResponderEvent\"));var _ResponderEventTypes=require(\"./ResponderEventTypes\");var _utils=require(\"./utils\");var _ResponderTouchHistoryStore=require(\"./ResponderTouchHistoryStore\");var _canUseDom=_interopRequireDefault(require(\"../canUseDom\"));var emptyObject={};var startRegistration=['onStartShouldSetResponderCapture','onStartShouldSetResponder',{bubbles:true}];var moveRegistration=['onMoveShouldSetResponderCapture','onMoveShouldSetResponder',{bubbles:true}];var scrollRegistration=['onScrollShouldSetResponderCapture','onScrollShouldSetResponder',{bubbles:false}];var shouldSetResponderEvents={touchstart:startRegistration,mousedown:startRegistration,touchmove:moveRegistration,mousemove:moveRegistration,scroll:scrollRegistration};var emptyResponder={id:null,idPath:null,node:null};var responderListenersMap=new Map();var isEmulatingMouseEvents=false;var trackedTouchCount=0;var currentResponder={id:null,node:null,idPath:null};var responderTouchHistoryStore=new _ResponderTouchHistoryStore.ResponderTouchHistoryStore();function changeCurrentResponder(responder){currentResponder=responder;}function getResponderConfig(id){var config=responderListenersMap.get(id);return config!=null?config:emptyObject;}function eventListener(domEvent){var eventType=domEvent.type;var eventTarget=domEvent.target;if(eventType==='touchstart'){isEmulatingMouseEvents=true;}if(eventType==='touchmove'||trackedTouchCount>1){isEmulatingMouseEvents=false;}if(eventType==='mousedown'&&isEmulatingMouseEvents||eventType==='mousemove'&&isEmulatingMouseEvents||eventType==='mousemove'&&trackedTouchCount<1){return;}if(isEmulatingMouseEvents&&eventType==='mouseup'){if(trackedTouchCount===0){isEmulatingMouseEvents=false;}return;}var isStartEvent=(0,_ResponderEventTypes.isStartish)(eventType)&&(0,_utils.isPrimaryPointerDown)(domEvent);var isMoveEvent=(0,_ResponderEventTypes.isMoveish)(eventType);var isEndEvent=(0,_ResponderEventTypes.isEndish)(eventType);var isScrollEvent=(0,_ResponderEventTypes.isScroll)(eventType);var isSelectionChangeEvent=(0,_ResponderEventTypes.isSelectionChange)(eventType);var responderEvent=(0,_createResponderEvent.default)(domEvent,responderTouchHistoryStore);if(isStartEvent||isMoveEvent||isEndEvent){if(domEvent.touches){trackedTouchCount=domEvent.touches.length;}else{if(isStartEvent){trackedTouchCount=1;}else if(isEndEvent){trackedTouchCount=0;}}responderTouchHistoryStore.recordTouchTrack(eventType,responderEvent.nativeEvent);}var eventPaths=(0,_utils.getResponderPaths)(domEvent);var wasNegotiated=false;var wantsResponder;if(isStartEvent||isMoveEvent||isScrollEvent&&trackedTouchCount>0){var currentResponderIdPath=currentResponder.idPath;var eventIdPath=eventPaths.idPath;if(currentResponderIdPath!=null&&eventIdPath!=null){var lowestCommonAncestor=(0,_utils.getLowestCommonAncestor)(currentResponderIdPath,eventIdPath);if(lowestCommonAncestor!=null){var indexOfLowestCommonAncestor=eventIdPath.indexOf(lowestCommonAncestor);var index=indexOfLowestCommonAncestor+(lowestCommonAncestor===currentResponder.id?1:0);eventPaths={idPath:eventIdPath.slice(index),nodePath:eventPaths.nodePath.slice(index)};}else{eventPaths=null;}}if(eventPaths!=null){wantsResponder=findWantsResponder(eventPaths,domEvent,responderEvent);if(wantsResponder!=null){attemptTransfer(responderEvent,wantsResponder);wasNegotiated=true;}}}if(currentResponder.id!=null&&currentResponder.node!=null){var _currentResponder=currentResponder,id=_currentResponder.id,node=_currentResponder.node;var _getResponderConfig=getResponderConfig(id),onResponderStart=_getResponderConfig.onResponderStart,onResponderMove=_getResponderConfig.onResponderMove,onResponderEnd=_getResponderConfig.onResponderEnd,onResponderRelease=_getResponderConfig.onResponderRelease,onResponderTerminate=_getResponderConfig.onResponderTerminate,onResponderTerminationRequest=_getResponderConfig.onResponderTerminationRequest;responderEvent.bubbles=false;responderEvent.cancelable=false;responderEvent.currentTarget=node;if(isStartEvent){if(onResponderStart!=null){responderEvent.dispatchConfig.registrationName='onResponderStart';onResponderStart(responderEvent);}}else if(isMoveEvent){if(onResponderMove!=null){responderEvent.dispatchConfig.registrationName='onResponderMove';onResponderMove(responderEvent);}}else{var isTerminateEvent=(0,_ResponderEventTypes.isCancelish)(eventType)||eventType==='contextmenu'||eventType==='blur'&&eventTarget===window||eventType==='blur'&&eventTarget.contains(node)&&domEvent.relatedTarget!==node||isScrollEvent&&trackedTouchCount===0||isScrollEvent&&eventTarget.contains(node)&&eventTarget!==node||isSelectionChangeEvent&&(0,_utils.hasValidSelection)(domEvent);var isReleaseEvent=isEndEvent&&!isTerminateEvent&&!(0,_utils.hasTargetTouches)(node,domEvent.touches);if(isEndEvent){if(onResponderEnd!=null){responderEvent.dispatchConfig.registrationName='onResponderEnd';onResponderEnd(responderEvent);}}if(isReleaseEvent){if(onResponderRelease!=null){responderEvent.dispatchConfig.registrationName='onResponderRelease';onResponderRelease(responderEvent);}changeCurrentResponder(emptyResponder);}if(isTerminateEvent){var shouldTerminate=true;if(eventType==='contextmenu'||eventType==='scroll'||eventType==='selectionchange'){if(wasNegotiated){shouldTerminate=false;}else if(onResponderTerminationRequest!=null){responderEvent.dispatchConfig.registrationName='onResponderTerminationRequest';if(onResponderTerminationRequest(responderEvent)===false){shouldTerminate=false;}}}if(shouldTerminate){if(onResponderTerminate!=null){responderEvent.dispatchConfig.registrationName='onResponderTerminate';onResponderTerminate(responderEvent);}changeCurrentResponder(emptyResponder);isEmulatingMouseEvents=false;trackedTouchCount=0;}}}}}function findWantsResponder(eventPaths,domEvent,responderEvent){var shouldSetCallbacks=shouldSetResponderEvents[domEvent.type];if(shouldSetCallbacks!=null){var idPath=eventPaths.idPath,nodePath=eventPaths.nodePath;var shouldSetCallbackCaptureName=shouldSetCallbacks[0];var shouldSetCallbackBubbleName=shouldSetCallbacks[1];var bubbles=shouldSetCallbacks[2].bubbles;var check=function check(id,node,callbackName){var config=getResponderConfig(id);var shouldSetCallback=config[callbackName];if(shouldSetCallback!=null){responderEvent.currentTarget=node;if(shouldSetCallback(responderEvent)===true){var prunedIdPath=idPath.slice(idPath.indexOf(id));return{id,node,idPath:prunedIdPath};}}};for(var i=idPath.length-1;i>=0;i--){var id=idPath[i];var node=nodePath[i];var result=check(id,node,shouldSetCallbackCaptureName);if(result!=null){return result;}if(responderEvent.isPropagationStopped()===true){return;}}if(bubbles){for(var _i=0;_i<idPath.length;_i++){var _id=idPath[_i];var _node=nodePath[_i];var _result=check(_id,_node,shouldSetCallbackBubbleName);if(_result!=null){return _result;}if(responderEvent.isPropagationStopped()===true){return;}}}else{var _id2=idPath[0];var _node2=nodePath[0];var target=domEvent.target;if(target===_node2){return check(_id2,_node2,shouldSetCallbackBubbleName);}}}}function attemptTransfer(responderEvent,wantsResponder){var _currentResponder2=currentResponder,currentId=_currentResponder2.id,currentNode=_currentResponder2.node;var id=wantsResponder.id,node=wantsResponder.node;var _getResponderConfig2=getResponderConfig(id),onResponderGrant=_getResponderConfig2.onResponderGrant,onResponderReject=_getResponderConfig2.onResponderReject;responderEvent.bubbles=false;responderEvent.cancelable=false;responderEvent.currentTarget=node;if(currentId==null){if(onResponderGrant!=null){responderEvent.currentTarget=node;responderEvent.dispatchConfig.registrationName='onResponderGrant';onResponderGrant(responderEvent);}changeCurrentResponder(wantsResponder);}else{var _getResponderConfig3=getResponderConfig(currentId),onResponderTerminate=_getResponderConfig3.onResponderTerminate,onResponderTerminationRequest=_getResponderConfig3.onResponderTerminationRequest;var allowTransfer=true;if(onResponderTerminationRequest!=null){responderEvent.currentTarget=currentNode;responderEvent.dispatchConfig.registrationName='onResponderTerminationRequest';if(onResponderTerminationRequest(responderEvent)===false){allowTransfer=false;}}if(allowTransfer){if(onResponderTerminate!=null){responderEvent.currentTarget=currentNode;responderEvent.dispatchConfig.registrationName='onResponderTerminate';onResponderTerminate(responderEvent);}if(onResponderGrant!=null){responderEvent.currentTarget=node;responderEvent.dispatchConfig.registrationName='onResponderGrant';onResponderGrant(responderEvent);}changeCurrentResponder(wantsResponder);}else{if(onResponderReject!=null){responderEvent.currentTarget=node;responderEvent.dispatchConfig.registrationName='onResponderReject';onResponderReject(responderEvent);}}}}var documentEventsCapturePhase=['blur','scroll'];var documentEventsBubblePhase=['mousedown','mousemove','mouseup','dragstart','touchstart','touchmove','touchend','touchcancel','contextmenu','select','selectionchange'];function attachListeners(){if(_canUseDom.default&&window.__reactResponderSystemActive==null){window.addEventListener('blur',eventListener);documentEventsBubblePhase.forEach(function(eventType){document.addEventListener(eventType,eventListener);});documentEventsCapturePhase.forEach(function(eventType){document.addEventListener(eventType,eventListener,true);});window.__reactResponderSystemActive=true;}}function addNode(id,node,config){(0,_utils.setResponderId)(node,id);responderListenersMap.set(id,config);}function removeNode(id){if(currentResponder.id===id){terminateResponder();}if(responderListenersMap.has(id)){responderListenersMap.delete(id);}}function terminateResponder(){var _currentResponder3=currentResponder,id=_currentResponder3.id,node=_currentResponder3.node;if(id!=null&&node!=null){var _getResponderConfig4=getResponderConfig(id),onResponderTerminate=_getResponderConfig4.onResponderTerminate;if(onResponderTerminate!=null){var event=(0,_createResponderEvent.default)({},responderTouchHistoryStore);event.currentTarget=node;onResponderTerminate(event);}changeCurrentResponder(emptyResponder);}isEmulatingMouseEvents=false;trackedTouchCount=0;}function getResponderNode(){return currentResponder.node;}","map":{"version":3,"names":["_createResponderEvent","_interopRequireDefault","require","_ResponderEventTypes","_utils","_ResponderTouchHistoryStore","_canUseDom","emptyObject","startRegistration","bubbles","moveRegistration","scrollRegistration","shouldSetResponderEvents","touchstart","mousedown","touchmove","mousemove","scroll","emptyResponder","id","idPath","node","responderListenersMap","Map","isEmulatingMouseEvents","trackedTouchCount","currentResponder","responderTouchHistoryStore","ResponderTouchHistoryStore","changeCurrentResponder","responder","getResponderConfig","config","get","eventListener","domEvent","eventType","type","eventTarget","target","isStartEvent","isStartish","isPrimaryPointerDown","isMoveEvent","isMoveish","isEndEvent","isEndish","isScrollEvent","isScroll","isSelectionChangeEvent","isSelectionChange","responderEvent","createResponderEvent","touches","length","recordTouchTrack","nativeEvent","eventPaths","getResponderPaths","wasNegotiated","wantsResponder","currentResponderIdPath","eventIdPath","lowestCommonAncestor","getLowestCommonAncestor","indexOfLowestCommonAncestor","indexOf","index","slice","nodePath","findWantsResponder","attemptTransfer","_currentResponder","_getResponderConfig","onResponderStart","onResponderMove","onResponderEnd","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","cancelable","currentTarget","dispatchConfig","registrationName","isTerminateEvent","isCancelish","window","contains","relatedTarget","hasValidSelection","isReleaseEvent","hasTargetTouches","shouldTerminate","shouldSetCallbacks","shouldSetCallbackCaptureName","shouldSetCallbackBubbleName","check","callbackName","shouldSetCallback","prunedIdPath","i","result","isPropagationStopped","_i","_id","_node","_result","_id2","_node2","_currentResponder2","currentId","currentNode","_getResponderConfig2","onResponderGrant","onResponderReject","_getResponderConfig3","allowTransfer","documentEventsCapturePhase","documentEventsBubblePhase","attachListeners","canUseDOM","__reactResponderSystemActive","addEventListener","forEach","document","addNode","setResponderId","set","removeNode","terminateResponder","has","delete","_currentResponder3","_getResponderConfig4","event","getResponderNode"],"sources":["/Users/sarahfitzgerald/SolStocksMobile/node_modules/react-native-web/dist/modules/useResponderEvents/ResponderSystem.js"],"sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * RESPONDER EVENT SYSTEM\n *\n * A single, global \"interaction lock\" on views. For a view to be the \"responder\" means\n * that pointer interactions are exclusive to that view and none other. The \"interaction\n * lock\" can be transferred (only) to ancestors of the current \"responder\" as long as\n * pointers continue to be active.\n *\n * Responder being granted:\n *\n * A view can become the \"responder\" after the following events:\n *  * \"pointerdown\" (implemented using \"touchstart\", \"mousedown\")\n *  * \"pointermove\" (implemented using \"touchmove\", \"mousemove\")\n *  * \"scroll\" (while a pointer is down)\n *  * \"selectionchange\" (while a pointer is down)\n *\n * If nothing is already the \"responder\", the event propagates to (capture) and from\n * (bubble) the event target until a view returns `true` for\n * `on*ShouldSetResponder(Capture)`.\n *\n * If something is already the responder, the event propagates to (capture) and from\n * (bubble) the lowest common ancestor of the event target and the current \"responder\".\n * Then negotiation happens between the current \"responder\" and a view that wants to\n * become the \"responder\": see the timing diagram below.\n *\n * (NOTE: Scrolled views either automatically become the \"responder\" or release the\n * \"interaction lock\". A native scroll view that isn't built on top of the responder\n * system must result in the current \"responder\" being notified that it no longer has\n * the \"interaction lock\" - the native system has taken over.\n *\n * Responder being released:\n *\n * As soon as there are no more active pointers that *started* inside descendants\n * of the *current* \"responder\", an `onResponderRelease` event is dispatched to the\n * current \"responder\", and the responder lock is released.\n *\n * Typical sequence of events:\n *  * startShouldSetResponder\n *  * responderGrant/Reject\n *  * responderStart\n *  * responderMove\n *  * responderEnd\n *  * responderRelease\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +--------------+          |                            |\n     | onTouchStart |          |                            |\n     +------+-------+    none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | | onResponder            | |\n            +------------------->|    TerminationRequest  | |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | | onResponderTerminate   |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\nimport createResponderEvent from './createResponderEvent';\nimport { isCancelish, isEndish, isMoveish, isScroll, isSelectionChange, isStartish } from './ResponderEventTypes';\nimport { getLowestCommonAncestor, getResponderPaths, hasTargetTouches, hasValidSelection, isPrimaryPointerDown, setResponderId } from './utils';\nimport { ResponderTouchHistoryStore } from './ResponderTouchHistoryStore';\nimport canUseDOM from '../canUseDom';\n\n/* ------------ TYPES ------------ */\n\nvar emptyObject = {};\n\n/* ------------ IMPLEMENTATION ------------ */\n\nvar startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {\n  bubbles: true\n}];\nvar moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {\n  bubbles: true\n}];\nvar scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {\n  bubbles: false\n}];\nvar shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\nvar emptyResponder = {\n  id: null,\n  idPath: null,\n  node: null\n};\nvar responderListenersMap = new Map();\nvar isEmulatingMouseEvents = false;\nvar trackedTouchCount = 0;\nvar currentResponder = {\n  id: null,\n  node: null,\n  idPath: null\n};\nvar responderTouchHistoryStore = new ResponderTouchHistoryStore();\nfunction changeCurrentResponder(responder) {\n  currentResponder = responder;\n}\nfunction getResponderConfig(id) {\n  var config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\n\n/**\n * Process native events\n *\n * A single event listener is used to manage the responder system.\n * All pointers are tracked in the ResponderTouchHistoryStore. Native events\n * are interpreted in terms of the Responder System and checked to see if\n * the responder should be transferred. Each host node that is attached to\n * the Responder System has an ID, which is used to look up its associated\n * callbacks.\n */\nfunction eventListener(domEvent) {\n  var eventType = domEvent.type;\n  var eventTarget = domEvent.target;\n\n  /**\n   * Manage emulated events and early bailout.\n   * Since PointerEvent is not used yet (lack of support in older Safari), it's\n   * necessary to manually manage the mess of browser touch/mouse events.\n   * And bailout early for termination events when there is no active responder.\n   */\n\n  // Flag when browser may produce emulated events\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  }\n  // Remove flag when browser will not produce emulated events\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  }\n  // Ignore various events in particular circumstances\n  if (\n  // Ignore browser emulated mouse events\n  eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents ||\n  // Ignore mousemove if a mousedown didn't occur first\n  eventType === 'mousemove' && trackedTouchCount < 1) {\n    return;\n  }\n  // Remove flag after emulated events are finished\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n    return;\n  }\n  var isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent);\n  var isMoveEvent = isMoveish(eventType);\n  var isEndEvent = isEndish(eventType);\n  var isScrollEvent = isScroll(eventType);\n  var isSelectionChangeEvent = isSelectionChange(eventType);\n  var responderEvent = createResponderEvent(domEvent, responderTouchHistoryStore);\n\n  /**\n   * Record the state of active pointers\n   */\n\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n    responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n\n  /**\n   * Responder System logic\n   */\n\n  var eventPaths = getResponderPaths(domEvent);\n  var wasNegotiated = false;\n  var wantsResponder;\n\n  // If an event occured that might change the current responder...\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\n    // If there is already a responder, prune the event paths to the lowest common ancestor\n    // of the existing responder and deepest target of the event.\n    var currentResponderIdPath = currentResponder.idPath;\n    var eventIdPath = eventPaths.idPath;\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      var lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);\n      if (lowestCommonAncestor != null) {\n        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);\n        // Skip the current responder so it doesn't receive unexpected \"shouldSet\" events.\n        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n    if (eventPaths != null) {\n      // If a node wants to become the responder, attempt to transfer.\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n      if (wantsResponder != null) {\n        // Sets responder if none exists, or negotates with existing responder.\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  }\n\n  // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.\n  if (currentResponder.id != null && currentResponder.node != null) {\n    var _currentResponder = currentResponder,\n      id = _currentResponder.id,\n      node = _currentResponder.node;\n    var _getResponderConfig = getResponderConfig(id),\n      onResponderStart = _getResponderConfig.onResponderStart,\n      onResponderMove = _getResponderConfig.onResponderMove,\n      onResponderEnd = _getResponderConfig.onResponderEnd,\n      onResponderRelease = _getResponderConfig.onResponderRelease,\n      onResponderTerminate = _getResponderConfig.onResponderTerminate,\n      onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node;\n\n    // Start\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderStart';\n        onResponderStart(responderEvent);\n      }\n    }\n    // Move\n    else if (isMoveEvent) {\n      if (onResponderMove != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderMove';\n        onResponderMove(responderEvent);\n      }\n    } else {\n      var isTerminateEvent = isCancelish(eventType) ||\n      // native context menu\n      eventType === 'contextmenu' ||\n      // window blur\n      eventType === 'blur' && eventTarget === window ||\n      // responder (or ancestors) blur\n      eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node ||\n      // native scroll without using a pointer\n      isScrollEvent && trackedTouchCount === 0 ||\n      // native scroll on node that is parent of the responder (allow siblings to scroll)\n      isScrollEvent && eventTarget.contains(node) && eventTarget !== node ||\n      // native select/selectionchange on node\n      isSelectionChangeEvent && hasValidSelection(domEvent);\n      var isReleaseEvent = isEndEvent && !isTerminateEvent && !hasTargetTouches(node, domEvent.touches);\n\n      // End\n      if (isEndEvent) {\n        if (onResponderEnd != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderEnd';\n          onResponderEnd(responderEvent);\n        }\n      }\n      // Release\n      if (isReleaseEvent) {\n        if (onResponderRelease != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderRelease';\n          onResponderRelease(responderEvent);\n        }\n        changeCurrentResponder(emptyResponder);\n      }\n      // Terminate\n      if (isTerminateEvent) {\n        var shouldTerminate = true;\n\n        // Responders can still avoid termination but only for these events.\n        if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {\n          // Only call this function is it wasn't already called during negotiation.\n          if (wasNegotiated) {\n            shouldTerminate = false;\n          } else if (onResponderTerminationRequest != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n            if (onResponderTerminationRequest(responderEvent) === false) {\n              shouldTerminate = false;\n            }\n          }\n        }\n        if (shouldTerminate) {\n          if (onResponderTerminate != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n            onResponderTerminate(responderEvent);\n          }\n          changeCurrentResponder(emptyResponder);\n          isEmulatingMouseEvents = false;\n          trackedTouchCount = 0;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Walk the event path to/from the target node. At each node, stop and call the\n * relevant \"shouldSet\" functions for the given event type. If any of those functions\n * call \"stopPropagation\" on the event, stop searching for a responder.\n */\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type]; // for Flow\n\n  if (shouldSetCallbacks != null) {\n    var idPath = eventPaths.idPath,\n      nodePath = eventPaths.nodePath;\n    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    var bubbles = shouldSetCallbacks[2].bubbles;\n    var check = function check(id, node, callbackName) {\n      var config = getResponderConfig(id);\n      var shouldSetCallback = config[callbackName];\n      if (shouldSetCallback != null) {\n        responderEvent.currentTarget = node;\n        if (shouldSetCallback(responderEvent) === true) {\n          // Start the path from the potential responder\n          var prunedIdPath = idPath.slice(idPath.indexOf(id));\n          return {\n            id,\n            node,\n            idPath: prunedIdPath\n          };\n        }\n      }\n    };\n\n    // capture\n    for (var i = idPath.length - 1; i >= 0; i--) {\n      var id = idPath[i];\n      var node = nodePath[i];\n      var result = check(id, node, shouldSetCallbackCaptureName);\n      if (result != null) {\n        return result;\n      }\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    }\n\n    // bubble\n    if (bubbles) {\n      for (var _i = 0; _i < idPath.length; _i++) {\n        var _id = idPath[_i];\n        var _node = nodePath[_i];\n        var _result = check(_id, _node, shouldSetCallbackBubbleName);\n        if (_result != null) {\n          return _result;\n        }\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      var _id2 = idPath[0];\n      var _node2 = nodePath[0];\n      var target = domEvent.target;\n      if (target === _node2) {\n        return check(_id2, _node2, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\n\n/**\n * Attempt to transfer the responder.\n */\nfunction attemptTransfer(responderEvent, wantsResponder) {\n  var _currentResponder2 = currentResponder,\n    currentId = _currentResponder2.id,\n    currentNode = _currentResponder2.node;\n  var id = wantsResponder.id,\n    node = wantsResponder.node;\n  var _getResponderConfig2 = getResponderConfig(id),\n    onResponderGrant = _getResponderConfig2.onResponderGrant,\n    onResponderReject = _getResponderConfig2.onResponderReject;\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node;\n\n  // Set responder\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n    changeCurrentResponder(wantsResponder);\n  }\n  // Negotiate with current responder\n  else {\n    var _getResponderConfig3 = getResponderConfig(currentId),\n      onResponderTerminate = _getResponderConfig3.onResponderTerminate,\n      onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;\n    var allowTransfer = true;\n    if (onResponderTerminationRequest != null) {\n      responderEvent.currentTarget = currentNode;\n      responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n      if (onResponderTerminationRequest(responderEvent) === false) {\n        allowTransfer = false;\n      }\n    }\n    if (allowTransfer) {\n      // Terminate existing responder\n      if (onResponderTerminate != null) {\n        responderEvent.currentTarget = currentNode;\n        responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n        onResponderTerminate(responderEvent);\n      }\n      // Grant next responder\n      if (onResponderGrant != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n        onResponderGrant(responderEvent);\n      }\n      changeCurrentResponder(wantsResponder);\n    } else {\n      // Reject responder request\n      if (onResponderReject != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderReject';\n        onResponderReject(responderEvent);\n      }\n    }\n  }\n}\n\n/* ------------ PUBLIC API ------------ */\n\n/**\n * Attach Listeners\n *\n * Use native events as ReactDOM doesn't have a non-plugin API to implement\n * this system.\n */\nvar documentEventsCapturePhase = ['blur', 'scroll'];\nvar documentEventsBubblePhase = [\n// mouse\n'mousedown', 'mousemove', 'mouseup', 'dragstart',\n// touch\n'touchstart', 'touchmove', 'touchend', 'touchcancel',\n// other\n'contextmenu', 'select', 'selectionchange'];\nexport function attachListeners() {\n  if (canUseDOM && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach(eventType => {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(eventType => {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\n\n/**\n * Register a node with the ResponderSystem.\n */\nexport function addNode(id, node, config) {\n  setResponderId(node, id);\n  responderListenersMap.set(id, config);\n}\n\n/**\n * Unregister a node with the ResponderSystem.\n */\nexport function removeNode(id) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\n\n/**\n * Allow the current responder to be terminated from within components to support\n * more complex requirements, such as use with other React libraries for working\n * with scroll views, input views, etc.\n */\nexport function terminateResponder() {\n  var _currentResponder3 = currentResponder,\n    id = _currentResponder3.id,\n    node = _currentResponder3.node;\n  if (id != null && node != null) {\n    var _getResponderConfig4 = getResponderConfig(id),\n      onResponderTerminate = _getResponderConfig4.onResponderTerminate;\n    if (onResponderTerminate != null) {\n      var event = createResponderEvent({}, responderTouchHistoryStore);\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n    changeCurrentResponder(emptyResponder);\n  }\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\n\n/**\n * Allow unit tests to inspect the current responder in the system.\n * FOR TESTING ONLY.\n */\nexport function getResponderNode() {\n  return currentResponder.node;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}